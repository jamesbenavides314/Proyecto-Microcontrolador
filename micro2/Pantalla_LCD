#include <xc.h>
#include <stdint.h>

// Configuraci贸n del PIC18F4550
#pragma config FOSC = INTOSCIO_EC  // Oscilador interno
#pragma config WDT = OFF           // Watchdog desactivado
#pragma config LVP = OFF           // Low Voltage Programming OFF
#pragma config PBADEN = OFF        // PORTB digital al inicio
#pragma config MCLRE = OFF          // MCLR habilitado
#pragma config PWRT = ON           // Power-up Timer habilitado
#pragma config BOR = ON            // Brown-out Reset habilitado
#pragma config XINST = OFF         // Extended instruction set OFF

#define _XTAL_FREQ 8000000  // Frecuencia de 8MHz

// Definici贸n de pines del LCD (modo 4 bits) - Usando PORTB
#define RS PORTBbits.RB0    // Register Select (Pin 4 del LCD)
#define EN PORTBbits.RB1    // Enable (Pin 6 del LCD)
#define D4 PORTBbits.RB4    // Data bit 4 (Pin 11 del LCD)
#define D5 PORTBbits.RB5    // Data bit 5 (Pin 12 del LCD)
#define D6 PORTBbits.RB6    // Data bit 6 (Pin 13 del LCD)
#define D7 PORTBbits.RB7    // Data bit 7 (Pin 14 del LCD)

// Prototipos de funciones
void LCD_Init(void);
void LCD_Command(uint8_t cmd);
void LCD_Data(uint8_t data);
void LCD_Write_String(const char *str);
void LCD_Clear(void);
void LCD_Set_Cursor(uint8_t row, uint8_t col);
void LCD_Pulse_Enable(void);

// Generar pulso en Enable
void LCD_Pulse_Enable(void) {
    EN = 1;              // pongo el pin enable en alto
    __delay_us(5);       // espero un poquito
    EN = 0;              // bajo el enable
    __delay_us(5);       // espero de nuevo
}

// Funci贸n para enviar nibble (4 bits) - Versi贸n mejorada
void LCD_Send_Nibble(uint8_t nibble) {
    // aqui separo los 4 bits y los mando a los pines D4-D7
    D4 = (nibble >> 0) & 0x01;  // primer bit
    D5 = (nibble >> 1) & 0x01;  // segundo bit
    D6 = (nibble >> 2) & 0x01;  // tercer bit
    D7 = (nibble >> 3) & 0x01;  // cuarto bit
    
    LCD_Pulse_Enable();   // mando el pulso para que el LCD lea
    __delay_us(50);       // espero un ratito
}

// Enviar comando al LCD
void LCD_Command(uint8_t cmd) {
    RS = 0;  // pongo RS en 0 porque voy a mandar un comando
    LCD_Send_Nibble(cmd >> 4);   // primero mando la parte alta del byte
    LCD_Send_Nibble(cmd & 0x0F); // luego mando la parte baja
    
    // algunos comandos necesitan mas tiempo
    if(cmd == 0x01 || cmd == 0x02) {
        __delay_ms(2);  // clear y home son lentos
    } else {
        __delay_us(100);  // para los demas comandos
    }
}
