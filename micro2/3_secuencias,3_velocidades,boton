#include <xc.h>


#pragma config FOSC = INTOSCIO_EC   
#pragma config WDT = OFF            
#pragma config LVP = OFF           
#pragma config PBADEN = OFF       
#pragma config PLLDIV = 1           
#pragma config CPUDIV = OSC1_PLL2  
#pragma config USBDIV = 2          
#pragma config FCMEN = OFF          
#pragma config IESO = OFF           
#pragma config MCLRE = OFF         

#define _XTAL_FREQ 8000000

// Variables globales
volatile unsigned char secuencia = 0;       // 0, 1, 2 (3 secuencias)
volatile unsigned char velocidad = 0;       // 0, 1, 2 (3 velocidades)
volatile unsigned char paso = 0;            // Paso actual de la secuencia

// Banderas para control de interrupciones
volatile unsigned char cambio_secuencia = 0;
volatile unsigned char cambio_velocidad = 0;

// Delays para las tres velocidades (en milisegundos)
const unsigned int delays[3] = {500, 250, 100};  // Lenta, Media, Rápida

// Función de retardo simple
void delay_ms(unsigned int ms) {
    while(ms--) {
        __delay_ms(1);
    }
}

// Rutina de servicio de interrupción - SOLO levanta banderas
void __interrupt() ISR(void) {
    // Interrupción INT0 - Cambio de secuencia
    if (INTCONbits.INT0IF) {
        if (cambio_secuencia == 0) {    // Solo si no hay una bandera pendiente
            cambio_secuencia = 1;       // Levantar bandera
        }
        INTCONbits.INT0IF = 0;          // Limpiar bandera de interrupción
    }
    
    // Interrupción INT1 - Cambio de velocidad
    if (INTCON3bits.INT1IF) {
        if (cambio_velocidad == 0) {    // Solo si no hay una bandera pendiente
            cambio_velocidad = 1;       // Levantar bandera
        }
        INTCON3bits.INT1IF = 0;         // Limpiar bandera de interrupción
    }
}

// Función para ejecutar la secuencia 1: Encendido secuencial
void secuencia_1(void) {
    if (paso == 0) {
        LATD = 0b00000001;  // Solo D0
    }
    else if (paso == 1) {
        LATD = 0b00000010;  // Solo D1
    }
    else if (paso == 2) {
        LATD = 0b00000100;  // Solo D2
    }
    else if (paso == 3) {
        LATD = 0b00001000;  // Solo D3
    }
    else if (paso == 4) {
        LATD = 0b00000000;  // Todos apagados
    }
    
    paso++;
    if (paso > 4) {
        paso = 0;
    }
}

// Función para ejecutar la secuencia 2: Ida y vuelta
void secuencia_2(void) {
    if (paso == 0) {
        LATD = 0b00000001;  // D0
    }
    else if (paso == 1) {
        LATD = 0b00000010;  // D1
    }
    else if (paso == 2) {
        LATD = 0b00000100;  // D2
    }
    else if (paso == 3) {
        LATD = 0b00001000;  // D3
    }
    else if (paso == 4) {
        LATD = 0b00000100;  // D2 (regreso)
    }
    else if (paso == 5) {
        LATD = 0b00000010;  // D1 (regreso)
    }
    
    paso++;
    if (paso > 5) {
        paso = 0;
    }
}
// Función para ejecutar la secuencia 3: Parpadeo alternado
void secuencia_3(void) {
    if (paso == 0) {
        LATD = 0b00001001;  // D0 y D3
    }
    else if (paso == 1) {
        LATD = 0b00000110;  // D1 y D2
    }
    else if (paso == 2) {
        LATD = 0b00001111;  // Todos encendidos
    }
    else if (paso == 3) {
        LATD = 0b00000000;  // Todos apagados
    }
    else if (paso == 4) {
        LATD = 0b00001010;  // D1 y D3
    }
    else if (paso == 5) {
        LATD = 0b00000101;  // D0 y D2
    }
    
    paso++;
    if (paso > 5) {
        paso = 0;
    }
}

void main(void) {
    // Configuración del oscilador interno a 8 MHz
    OSCCONbits.IRCF = 0b111;    
    OSCCONbits.SCS = 0b10;      
    
    // Configuración de pines
    TRISBbits.TRISB0 = 1;       // RB0 como entrada (INT0 - Sensor táctil)
    TRISBbits.TRISB1 = 1;       // RB1 como entrada (INT1 - Sensor táctil)
    TRISDbits.TRISD0 = 0;       // RD0 como salida (LED 1)
    TRISDbits.TRISD1 = 0;       // RD1 como salida (LED 2)
    TRISDbits.TRISD2 = 0;       // RD2 como salida (LED 3)
    TRISDbits.TRISD3 = 0;       // RD3 como salida (LED 4)
    
    LATD = 0x00;                // Apagar todos los LEDs
    ADCON1 = 0x0F;              // Todas las entradas como digitales
    
    // Configuración de interrupciones INT0
    INTCONbits.INT0IF = 0;      // Limpiar bandera
    INTCON2bits.INTEDG0 = 1;    // Flanco de subida
    INTCONbits.INT0IE = 1;      // Habilitar INT0
    
    // Configuración de interrupciones INT1
    INTCON3bits.INT1IF = 0;     // Limpiar bandera
    INTCON2bits.INTEDG1 = 1;    // Flanco de subida
    INTCON3bits.INT1IE = 1;     // Habilitar INT1
    
    INTCONbits.GIE = 1;         // Habilitar interrupciones globales
    
    // Bucle principal
    while (1) {
        // Revisar si hay que cambiar la secuencia
        if (cambio_secuencia == 1) {
            __delay_ms(50);  // Anti-rebote
            
            secuencia++;
            if (secuencia > 2) {
                secuencia = 0;
            }
            paso = 0;  // Reiniciar paso
            
            cambio_secuencia = 0;  // Bajar bandera
        }
        
        // Revisar si hay que cambiar la velocidad
        if (cambio_velocidad == 1) {
            __delay_ms(50);  // Anti-rebote
            
            velocidad++;
            if (velocidad > 2) {
                velocidad = 0;
            }
            
            cambio_velocidad = 0;  // Bajar bandera
        }
        
        // Ejecutar la secuencia que corresponde
        if (secuencia == 0) {
            secuencia_1();
        }
        else if (secuencia == 1) {
            secuencia_2();
        }
        else if (secuencia == 2) {
            secuencia_3();
        }
        
        // Aplicar el retardo según la velocidad
        delay_ms(delays[velocidad]);
    }
}
